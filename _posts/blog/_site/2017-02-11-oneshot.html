<h1 id="under-construction---move-along-this-probably-doesnt-make-sense-yet">UNDER CONSTRUCTION - MOVE ALONG THIS PROBABLY DOESNT MAKE SENSE YET</h1>

<p><em>[Epistemic status: I have no formal training in machine learning or statistics so some of this might be wrong/misleading, but I’ve tried my best.]</em></p>

<h3 id="background">Background:</h3>

<p>Conventional wisdom holds that deep neural networks are really good at classifying high dimensional data like images, but only when they have huge amounts of labelled examples to train on. Humans on the other hand, are capable of <em>one-shot learning</em> - if you take a human who’s never seen a spatula before, and show them a single picture of a spatula, they will probably be able to distinguish spatulas from other kitchen utensils with extremely high accuracy.</p>

<p><img src="/images/spatula.jpg" alt="test" /></p>

<p><em>Never seen a spatula before? Now’s your chance to test your one shot learning ability! Email me for the correct answer.</em></p>

<p>Yet another one of the <a href="https://dspace.mit.edu/handle/1721.1/6125" title="..back in the 1960s, some of the early pioneers of AI set some undergrads the task of building a complete computer vision system over summer">things</a> humans can do that seemed trivial to us right up until we tried to make an algorithm do it. This ability also seems like it’s obviously desirable for machine learning systems to have and an important step towards general intelligence.</p>

<p>Recently there have been <a href="&quot;&quot;">many</a> <a href="&quot;&quot;">interesting</a> <a href="&quot;&quot;">papers</a> about one-shot learning with neural nets and they’ve gotten some good results. This is a new area that really excites me, so I wanted to make a gentle intoduction to make it more accessible to fellow newcomers to deep learning.</p>

<p>In this post, I want to:</p>
<ul>
  <li>Introduce and formulate the problem of one-shot learning</li>
  <li>Describe benchmarks for one-shot classification and give a baseline for performance</li>
  <li>Give an example of deep one-shot learning by reimplementing <a href="">this paper</a></li>
</ul>

<h2 id="formulating-the-problem----n-way-one-shot-learning">Formulating the Problem  - N-way One-Shot Learning</h2>

<p>Before we try to solve any problem, we should first precisely state what the problem actually is, so here is the problem of one-shot classification expressed symbolically:</p>

<p>Our model is given a tiny labelled training set  \( S \), which has N examples, each of a different class.</p>

<p>\( S =  { x_c }_{c=1}^{N} \)</p>

<p>It is also given \( x\hat{} \), the test example it has to classify.</p>

<p>Note that when N is higher, there are more possible classes that  \( x\hat{} \) can belong to, so it’s harder to  guess the correct one. Random guessing will get 100/N% accuracy.</p>

<h4 id="omniglot-">Omniglot :</h4>

<p>The <a href="https://github.com/brendenlake/omniglot" title=" Lake, B. M., Salakhutdinov, R., and Tenenbaum, J. B. (2015). Human-level concept learning through probabilistic program induction. Science, 350(6266), 1332-1338.">Omniglot dataset</a> is a collection of 1623 hand drawn characters from 50 alphabets. For every character there are just 20 examples, each drawn by a different person at resolution 105x105. It’s sometimes referred to as the <em>transpose</em> of <a href="https://en.wikipedia.org/wiki/MNIST_database">MNIST</a>, since it has 1623 types of character with only 20 examples each, in contrast to MNIST having thousands of examples for only 10 digits.</p>

<p>It serves as a really good benchmark for one shot classification algorithms.</p>

<h4 id="a-naive-one-shot-learner---1-nearest-neighbour">A Naive One-Shot Learner - 1 Nearest Neighbour</h4>

<p>The simplest way of doing classification is with k-nearest neighbours, but since there is only one example per class we have to do 1 nearest neighbour.</p>

<h4 id="ways-to-use-deep-networks-for-one-shot-learning">Ways to use deep networks for one shot learning?!</h4>

<p>If we naively train a neural network on a one-shot as a vanilla cross-entropy-loss softmax classifier, it will <em>severely</em> overfit. Heck, even if it was a <em>hundred</em> shot learning a modern neural net would still probably overfit. Having hundreds of thousands of parameters to gradient-descend when you have only 1 example per class seems like it’s obviously a bad idea.</p>

<p>But is optimizng lots of parameters is a bad idea for this problem, why on earth would anyone want to use deep learning?</p>

<p>Because they’re the best at extracting useful features from high dimensional data with complex structure like images. Maybe a neural net could learn <em>something</em> useful from training data that is similar to that in the one-shot testing tasks. Then we could use that something</p>

<p>Sounds confusing? Think back to 1 nearest neighbour. This simple, non-parametric one-shot learner just classifies the test example with the same class of whatever support example is the closest in L2 distance. This works ok but L2 Distance suffers from the ominous sounding <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality">curse of dimensionality</a> and so won’t work well for data with thousands of dimensions like images or audio. Deep learning to the rescue! We can give a deep model many examples of images similar to the ones we want to classify and get it to learn another similarity function to replace L2 distance. This similarity measure can then be used in a 1 nearest-neighbour classifier, which is more or less what the siamese network I’m reimplementing does.</p>

<p>Note that this isn’t the only way to learn a non-parametric classifier; <a href="">Lillicrap et al, Matching Networks for One-Shot Learning</a> learns a complete nearest neighbours classifier end-to-end, not just a metric, comparing the test example with the entire support set, rather than just one example, and gets better results too.</p>

<p>This can all be viewed as a sort of meta-learning - a deep neural network learns a model that is good at one-shot learning. Because of the no free lunch theorem we can’t learn a classifier that will work on all kinds of data, but</p>

<h4 id="measuring-one-shot-generalization">Measuring One-Shot Generalization</h4>

<p>ML algorithms often have problems with overfitting, where they learn features that don’t generalize well to examples they haven’t seen before or just memorize the training set. In traditional supervised learning this is controlled by <em>cross validation</em>, where some of the training data is set aside to be the <em>validation set</em>. The model doesn’t train on part of the validation set but rather is evaluated on it during training, so the user can judge how the model performs on examples it hasn’t seen before.</p>

<p>This approach to one-shot learning(neural network approximation of non parametric classifier) is prone to overfitting too - since we train our . A one-shot learner has to be good at classifying not only <em>data</em> it hasn’t seen before, but also <em>classes of data</em> it hasn’t seen before. If we test a one-shot learner with symbols of types the metric learner has already seen, we’re no longer testing one-shot learning. So to properly measure one-shot generalization, we need a validation set of examples that are of different classes to the training set.</p>

<p>We do have to assume that the examples in the validation task have some kind of structural similarity to examples in the training set though - it would be silly to expect to learn a one-shot imagenet classifier by training on omniglot for instance.</p>

<h3 id="siamese-networks">Siamese networks</h3>

<p><a href="http://www.cs.cmu.edu/~rsalakhu/papers/oneshot1.pdf">This wonderful paper</a> is what I will be implementing in this tutorial. Koch et al’s approach to getting a neural net to do one-shot classification is to give it two images and train it to guess whether they have the same category. Then when doing a one-shot classification task described above, the network can compare the test image to each image in the support set, and pick which one it thinks is most likely to be of the same category. So we want a neural net architecture that takes two images as input and outputs the probability they share the same class.</p>

<p>Say \( x_1 \) and \( x_2 \) are two images in our dataset, and let  \( x_1 \circ x_2 \) mean “\( x_1 \) and \( x_2 \) are images with the same class”. Note that  \( x_1 \circ x_2 \) is the same as \( x_2 \circ x_1 \) - this means that if we reverse the order of the inputs to the neural network, the output should be the same -  \( p(x_1  \circ x_2) \) should equal \( p(x_2 \circ x_1) \).</p>

<p>If we we just concatenate two examples together and use them as a single input to a neural net, each example will be matrix multiplied(or convolved) with a different set of weights, which breaks symmetry. Sure it’s possible it will eventually manage to learn the exact same weights for each input, but it would be much easier to learn a single set of weights applied to both inputs. So we could propagate both inputs through identical twin neural nets with shared parameters, then use the absolute difference as the input to a linear classifier - this is essentially what a siamese net is. Two identical twins, joined at the head, hence the name.</p>

<h4 id="network-architecture">Network architecture</h4>

<p>I’m going to describe the architecture pretty breifly because it’s not the important part of the paper. Koch et al uses a <em>convolutional</em> siamese network to classify pairs of omniglot images, so the twin networks are both convolutional neural nets(CNNs). The twins each have the following architecture: convolution with 64 10x10 filters,relu -&gt; max pool -&gt; convolution with 128 7x7 filters, relu -&gt; max pool -&gt; convolution with 128 4x4 filters, relu -&gt; max pool -&gt; convolution with 256 4x4 filters. The twin networks reduce their inputs down to smaller and smaller 3d tensors, and their final outputs are flattened into vectors of length 4096. The absolute difference between the two vectors is used as input to a linear classifier.</p>

<p><em>(If the previous paragraph sounded like jibberish, I’d suggest checking out <a href="http://cs231n.github.io/convolutional-networks/">cs231n</a> and then <a href="http://colah.github.io/posts/tags/convolutional_neural_networks.html">colah</a>.
Synopsis for laypeople: a convolutional layer is where you use multiple copies of the same neuron for different parts of an array. Lots of these stacked on top of one another are really good at learning from images)</em></p>

<p>The output is squashed into [0,1] with a sigmoid function. We use the label \(t = 1\) when the images have the same class and \(t = 0\) for a different class. It’s trained with logistic regression. This means the loss function should be binary cross entropy between the predictions and targets.</p>

<p>\[ L(x_1,x_2,t) = t * log(p(x_1 \circ x_2)) + (1 - t) * log(1-p(x_1 \circ x_2))  \]</p>

<p>There is also a L2 weight decay term in the loss to encourage the network to learn smaller/less noisy weights and possibly improve generalization:</p>

<table>
  <tbody>
    <tr>
      <td>\[ L(x_1,x_2,t) = t * log(p(x_1 \circ x_2)) + (1 - t) * log(1-p(x_1 \circ x_2)) + \lambda *</td>
      <td>w</td>
      <td>_2  \]</td>
    </tr>
  </tbody>
</table>

<h4 id="history">History</h4>

<p>Siamese networks, like every other cool neural net architecture, were <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.590.7750&amp;rep=rep1&amp;type=pdf" title="Baldi and Chauvin(1992).">originally</a> thought up in the 90s and have been applied to new problems with the power of modern GPUs. Also, <a href="">Yann Lecun like them before they were cool</a></p>

<h4 id="code">Code:</h4>

<p>Imports:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Convolution2D</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">merge</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Flatten</span><span class="p">,</span><span class="n">MaxPooling2D</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Model</span><span class="p">,</span> <span class="n">Sequential</span>
<span class="kn">from</span> <span class="nn">keras</span> <span class="kn">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">K</span>
<span class="kn">from</span> <span class="nn">keras.optimizers</span> <span class="kn">import</span> <span class="n">SGD</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="kn">as</span> <span class="nn">rng</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">dill</span> <span class="kn">as</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span></code></pre></figure>

<p>Now we define the model. We need two input layers, one for each digit:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">105</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">left_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
<span class="n">right_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span></code></pre></figure>

<p>The convnet as a Sequential() model, using the same architecure as the original paper. Since the siamese network legs share weights, we only need to define it once and then call it with each leg’s input layer.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">convnet</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Convolution2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">,</span><span class="n">subsample</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">input_shape</span><span class="o">=</span><span class="n">input_shape</span><span class="p">))</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">())</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Convolution2D</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">))</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">())</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Convolution2D</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">))</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">())</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Convolution2D</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">))</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">())</span>
<span class="n">convnet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">4096</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">"sigmoid"</span><span class="p">))</span>
<span class="n">encoded_l</span> <span class="o">=</span> <span class="n">convnet</span><span class="p">(</span><span class="n">left_input</span><span class="p">)</span>
<span class="n">encoded_r</span> <span class="o">=</span> <span class="n">convnet</span><span class="p">(</span><span class="n">right_input</span><span class="p">)</span></code></pre></figure>

<p>Keras allows you to merge layers together with a lambda(one line function), so we use that to get the L1 distance between the output of each leg.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">L1_distance</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">both</span> <span class="o">=</span> <span class="n">merge</span><span class="p">([</span><span class="n">encoded_l</span><span class="p">,</span><span class="n">encoded_r</span><span class="p">],</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">L1_distance</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></figure>

<p>..now use the L1 distance as an input to a fully connected layer with a single output and sigmoid to squash the output into [0,1] and make it a probabilty. Compile with binary cross entropy as the loss and the same optimizer as the paper.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">prediction</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'sigmoid'</span><span class="p">)(</span><span class="n">both</span><span class="p">)</span>
<span class="n">siamese_net</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="p">[</span><span class="n">left_input</span><span class="p">,</span><span class="n">right_input</span><span class="p">],</span><span class="n">output</span><span class="o">=</span><span class="n">prediction</span><span class="p">)</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">SGD</span><span class="p">(</span><span class="mf">0.009</span><span class="p">,</span><span class="n">momentum</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span><span class="n">nesterov</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">decay</span><span class="o">=</span><span class="mf">0.0003</span><span class="p">)</span>
<span class="n">siamese_net</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">"binary_crossentropy"</span><span class="p">,</span><span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">)</span></code></pre></figure>

<p>Since the omniglot dataset has exactly 20 of each sample, I arranged it as a Cx20x105x105 array to make it easier to index by class when loading data. Since there are 20 examples for all 623 classes, there are 62320 = ?? pairs to train on. In Koch et al they use a training set size of ????, but that wouldn’t fit in my computers memory. I decided to just randomly sample pairs for training because I ran out of time. I’m also</p>
